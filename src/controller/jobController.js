import { StatusCodes } from 'http-status-codes';
import { HandleResponse } from '../helpers/handleResponse.js';
import {
    createJobService,
    deletJobService,
    fetchJobsByVendorService,
    fetchJobService,
    updateJobService,
} from '../services/jobService.js';
import { Message } from '../utils/constant/message.js';
import logger from '../loggers/logger.js';
import { pagination } from '../helpers/commonFunction/handlePagination.js';
import jobs from '../models/jobModel.js';
import { generateJobId } from '../helpers/generateApplicationNo.js';

export const createJob = async (req, res) => {
    try {
        const user = req.user.id;
        const job_id = await generateJobId();
        const applicationDeadline = new Date();
        applicationDeadline.setDate(applicationDeadline.getDate() + 30);
        const finalDate = applicationDeadline.toLocaleDateString('en-CA');
        const jobData = {
            job_id,
            addedBy: user,
            application_deadline: finalDate,
            ...req.body,
        };
        await createJobService(jobData);
        logger.info(`job ${Message.ADDED_SUCCESSFULLY}`);
        return HandleResponse(
            res,
            true,
            StatusCodes.CREATED,
            `job ${Message.ADDED_SUCCESSFULLY}`,
            jobData
        );
    } catch (error) {
        logger.error(`${Message.FAILED_TO} add job`, error);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} add job`
        );
    }
};

export const viewJobs = async (req, res) => {
    try {
        const {
            page = 1,
            limit = 10,
            search,
            job_type,
            salary_currency,
            salary_frequency,
            min_salary,
            max_salary,
            min_experience,
            work_preference,
            required_skills,
            job_location
        } = req.query;
        const query = {};
        if (search && typeof search === 'string') {
            const cleanSearch = search.replace(/[^a-zA-Z0-9]/g, '');
            const flexiblePattern = cleanSearch.split('').join('[-_\\s]*');
            const regex = new RegExp(flexiblePattern, 'i');
            query.$or = [
                { job_subject: { $regex: regex } },
                { job_type: { $regex: regex } },
            ];
        }

        if (job_type) {
            query.job_type = job_type;
        }

        if (salary_currency) {
            query.salary_currency = salary_currency;
        }

        if (salary_frequency) {
            query.salary_frequency = salary_frequency;
        }

        if (min_salary) {
            query.min_salary = { $gte: parseInt(min_salary) };
        }

        if (max_salary) {
            query.max_salary = { $lte: parseInt(max_salary) };
        }

        if (min_experience) {
            query.min_experience = { $gte: parseInt(min_experience) };
        }

        if (work_preference) {
            query.work_preference = work_preference;
        }

        if (job_location) {
            query.job_location = job_location;
        }

        if (required_skills) {
            const skillsArray = required_skills
                .split(',')
                .map((skill) => skill.trim())
                .filter((skill) => skill.length > 0);

            if (skillsArray.length > 0) {
                const regexPatterns = skillsArray.map(
                    (skill) =>
                        new RegExp(skill.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i')
                );
                query.required_skills = { $in: regexPatterns };
            }
        }

        const result = await pagination({
            Schema: jobs,
            page: parseInt(page),
            limit: parseInt(limit),
            query,
            sort: { createdAt: -1 },
        });

        if (!result || result?.length === 0) {
            logger.error(`Jobs ${Message.NOT_FOUND}`);
            return HandleResponse(
                res,
                false,
                StatusCodes.NOT_FOUND,
                `Jobs ${Message.NOT_FOUND}`
            );
        }

        logger.info(`All jobs ${Message.FETCH_SUCCESSFULLY}`);
        return HandleResponse(res, true, StatusCodes.OK, undefined, result);
    } catch (error) {
        logger.error(`${Message.FAILED_TO} fetch job`);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} fetchjob`
        );
    }
};

export const viewJobDetails = async (req, res) => {
    try {
        const jobId = req.params.id;
        const result = await fetchJobService(jobId);
        if (!result) {
            logger.error(`Job ${Message.NOT_FOUND}`);
            return HandleResponse(
                res,
                false,
                StatusCodes.NOT_FOUND,
                `Job ${Message.NOT_FOUND}`
            );
        }
        logger.info(`Job ${Message.FETCH_SUCCESSFULLY}`);
        return HandleResponse(res, true, StatusCodes.OK, undefined, result);
    } catch (error) {
        logger.error(`${Message.FAILED_TO} fetch job`);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} fetch job`
        );
    }
};

export const updateJob = async (req, res) => {
    try {
        const jobId = req.params.id;
        const existJob = await fetchJobService(jobId);
        if (!existJob) {
            logger.error(`Job ${Message.NOT_FOUND}`);
            return HandleResponse(
                res,
                false,
                StatusCodes.NOT_FOUND,
                `Job ${Message.NOT_FOUND}`
            );
        }
        await updateJobService(jobId, req.body);
        logger.info(`Job ${Message.UPDATED_SUCCESSFULLY}`);
        return HandleResponse(
            res,
            true,
            StatusCodes.ACCEPTED,
            `Job ${Message.UPDATED_SUCCESSFULLY}`
        );
    } catch (error) {
        logger.error(`${Message.FAILED_TO} fetch job`);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} update job`
        );
    }
};

export const deleteJob = async (req, res) => {
    try {
        const { ids } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
            logger.error(`Job ${Message.NOT_FOUND}`);
            return HandleResponse(
                res,
                false,
                StatusCodes.BAD_REQUEST,
                `Job ${Message.NOT_FOUND}`
            );
        }
        const removeJob = await deletJobService(ids);
        if (removeJob.deletedCount === 0) {
            logger.error(`Job  ${Message.NOT_FOUND}`);
            return HandleResponse(
                res,
                false,
                StatusCodes.NOT_FOUND,
                `Job ${Message.NOT_FOUND}`
            );
        }
        const message =
            removeJob.deletedCount > 1
                ? `${removeJob.deletedCount} jobs ${Message.DELETED_SUCCESSFULLY}`
                : `${removeJob.deletedCount} Job ${Message.DELETED_SUCCESSFULLY}`;
        logger.info(message);
        return HandleResponse(res, true, StatusCodes.OK, message, removeJob);
    } catch (error) {
        logger.error(`${Message.FAILED_TO} delete jobs.`);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} delete jobs.`
        );
    }
};

export const viewJobsByVendorId = async (req, res) => {
    try {
        const vendorId = req.params.id;
        const findJobs = await fetchJobsByVendorService(vendorId);
        if (!findJobs) {
            return HandleResponse(
                res,
                false,
                StatusCodes.NOT_FOUND,
                `Job ${Message.NOT_FOUND}`
            );
        }
        logger.info(`Job ${Message.FETCH_SUCCESSFULLY}`);
        return HandleResponse(res, true, StatusCodes.OK, undefined, findJobs);
    } catch (error) {
        logger.error(`${Message.FAILED_TO} fetch job`);
        return HandleResponse(
            res,
            false,
            StatusCodes.INTERNAL_SERVER_ERROR,
            `${Message.FAILED_TO} fetch job`
        );
    }
};
